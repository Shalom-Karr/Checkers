<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Checkers vs AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body { font-family: 'Inter', sans-serif; }
        
        .checker-piece {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }
        .checker-piece:hover {
            transform: scale(1.05);
        }
        .selected {
            box-shadow: 0 0 0 4px #fbbf24;
            transform: scale(1.1) !important;
            z-index: 10;
        }
        .valid-move::after {
            content: '';
            display: block;
            width: 24px;
            height: 24px;
            background: rgba(251, 191, 36, 0.6);
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        .last-move {
            background-color: rgba(255, 255, 255, 0.15) !important;
        }
        @keyframes pulse {
            0% { transform: scale(0.95); box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.7); }
            70% { transform: scale(1); box-shadow: 0 0 0 10px rgba(251, 191, 36, 0); }
            100% { transform: scale(0.95); box-shadow: 0 0 0 0 rgba(251, 191, 36, 0); }
        }
    </style>
</head>
<body class="bg-slate-900 min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Header & Controls -->
    <div class="mb-6 w-full max-w-lg text-center">
        <h1 class="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-red-500 to-orange-400 mb-6 tracking-tight">
            Checkers AI
        </h1>
        
        <div class="flex flex-col sm:flex-row gap-4 justify-center items-center mb-6">
            <select id="game-mode" onchange="resetGame()" class="bg-slate-800 text-white border border-slate-600 rounded-lg px-4 py-2 font-medium focus:outline-none focus:ring-2 focus:ring-red-500 cursor-pointer">
                <option value="pvp">Player vs Player</option>
                <option value="ai-easy">Player vs AI (Easy)</option>
                <option value="ai-medium" selected>Player vs AI (Medium)</option>
                <option value="ai-hard">Player vs AI (Hard)</option>
            </select>
            
            <button onclick="resetGame()" class="bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg font-medium transition shadow-lg">
                Restart Game
            </button>
        </div>

        <div id="turn-indicator" class="inline-block px-8 py-2 rounded-full font-bold text-sm tracking-widest transition-all duration-300 shadow-lg bg-red-500 text-white uppercase">
            Red's Turn
        </div>
    </div>

    <!-- Game Board -->
    <div class="relative bg-slate-800 p-3 sm:p-5 rounded-2xl shadow-2xl border border-slate-700">
        <div id="board" class="grid grid-cols-8 grid-rows-8 border-4 border-slate-900 w-[320px] h-[320px] sm:w-[480px] sm:h-[480px] rounded bg-slate-900">
            <!-- Squares generated by JS -->
        </div>
        
        <!-- Game Over Overlay -->
        <div id="game-over" class="hidden absolute inset-0 bg-slate-900/90 rounded-2xl flex-col items-center justify-center z-50">
            <h2 id="winner-text" class="text-5xl font-bold text-white mb-6">Red Wins!</h2>
            <button onclick="resetGame()" class="bg-red-500 hover:bg-red-600 text-white px-8 py-3 rounded-full font-bold text-lg transition shadow-xl transform hover:scale-105">
                Play Again
            </button>
        </div>
    </div>

    <!-- Instructions -->
    <div class="mt-8 text-slate-400 text-sm max-w-md text-center bg-slate-800/50 p-4 rounded-xl border border-slate-700/50">
        <p><strong>Rules:</strong> Jumps are <strong>NOT</strong> mandatory. You can choose to jump or make a normal move. Pieces become Kings (♔) upon reaching the opposite end.</p>
    </div>

    <script>
        // Constants
        const EMPTY = 0, RED = 1, BLACK = 2, RED_KING = 3, BLACK_KING = 4;
        const BOARD_SIZE = 8;
        
        // DOM Elements
        const boardElement = document.getElementById('board');
        const turnIndicator = document.getElementById('turn-indicator');
        const gameModeSelect = document.getElementById('game-mode');
        const gameOverScreen = document.getElementById('game-over');
        const winnerText = document.getElementById('winner-text');

        // Global State
        let gameState = {
            board: [],
            turn: 'red',
            multiJumpPiece: null, // Index of piece that must continue jumping
            lastMove: null
        };
        
        let selectedSquare = null;
        let currentLegalMoves = [];
        let isProcessing = false;

        // Initialize
        function initBoard() {
            let board = Array(64).fill(EMPTY);
            for (let i = 0; i < 64; i++) {
                let row = Math.floor(i / 8);
                let col = i % 8;
                if ((row + col) % 2 !== 0) {
                    if (row < 3) board[i] = BLACK;
                    if (row > 4) board[i] = RED;
                }
            }
            return { board, turn: 'red', multiJumpPiece: null, lastMove: null };
        }

        function resetGame() {
            gameState = initBoard();
            selectedSquare = null;
            currentLegalMoves = [];
            isProcessing = false;
            gameOverScreen.classList.add('hidden');
            updateUI();
        }

        // --- Core Game Logic ---

        function isPlayerPiece(piece, turn) {
            if (turn === 'red') return piece === RED || piece === RED_KING;
            if (turn === 'black') return piece === BLACK || piece === BLACK_KING;
            return false;
        }

        function isOpponent(piece, turn) {
            if (turn === 'red') return piece === BLACK || piece === BLACK_KING;
            if (turn === 'black') return piece === RED || piece === RED_KING;
            return false;
        }

        function getDirections(piece) {
            let dirs = [];
            if (piece === RED || piece === RED_KING || piece === BLACK_KING) dirs.push({r: -1, c: -1}, {r: -1, c: 1});
            if (piece === BLACK || piece === BLACK_KING || piece === RED_KING) dirs.push({r: 1, c: -1}, {r: 1, c: 1});
            return dirs;
        }

        function isValid(r, c) {
            return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;
        }

        function getLegalMoves(state) {
            let moves = [];
            let jumps = [];
            
            // If in a multi-jump sequence, only that piece can move
            let indices = state.multiJumpPiece !== null ? [state.multiJumpPiece] : Array.from({length: 64}, (_, i) => i);
            
            for (let i of indices) {
                let p = state.board[i];
                if (!isPlayerPiece(p, state.turn)) continue;
                
                let row = Math.floor(i / 8);
                let col = i % 8;
                let dirs = getDirections(p);
                
                for (let d of dirs) {
                    let r = row + d.r;
                    let c = col + d.c;
                    
                    if (isValid(r, c)) {
                        let targetIdx = r * 8 + c;
                        
                        // Normal move (only if not currently multi-jumping)
                        if (state.board[targetIdx] === EMPTY && state.multiJumpPiece === null) {
                            moves.push({ from: i, to: targetIdx, capture: null });
                        } 
                        // Jump
                        else if (isOpponent(state.board[targetIdx], state.turn)) {
                            let jr = r + d.r;
                            let jc = c + d.c;
                            if (isValid(jr, jc)) {
                                let jIdx = jr * 8 + jc;
                                if (state.board[jIdx] === EMPTY) {
                                    jumps.push({ from: i, to: jIdx, capture: targetIdx });
                                }
                            }
                        }
                    }
                }
            }
            
            // COMBINE normal moves and jumps so jumps are NO LONGER mandatory
            return [...moves, ...jumps];
        }

        function applyMoveToState(state, move) {
            let newState = { 
                board: [...state.board], 
                turn: state.turn, 
                multiJumpPiece: null,
                lastMove: { from: move.from, to: move.to } 
            };
            
            let p = newState.board[move.from];
            newState.board[move.to] = p;
            newState.board[move.from] = EMPTY;
            
            let captured = false;
            if (move.capture !== null) {
                newState.board[move.capture] = EMPTY;
                captured = true;
            }
            
            // Promotion
            let row = Math.floor(move.to / 8);
            let promoted = false;
            if (p === RED && row === 0) { newState.board[move.to] = RED_KING; promoted = true; }
            if (p === BLACK && row === 7) { newState.board[move.to] = BLACK_KING; promoted = true; }
            
            // Check Multi-jump
            if (captured && !promoted) {
                let tempState = { board: newState.board, turn: state.turn, multiJumpPiece: move.to };
                if (getLegalMoves(tempState).length > 0) {
                    newState.multiJumpPiece = move.to;
                    return newState; // Turn continues!
                }
            }
            
            // Switch Turn
            newState.turn = state.turn === 'red' ? 'black' : 'red';
            return newState;
        }

        // --- Minimax AI ---
        
        function evaluateBoard(board) {
            let score = 0;
            for (let i = 0; i < 64; i++) {
                let p = board[i];
                if (p === EMPTY) continue;
                
                let row = Math.floor(i / 8);
                // AI is BLACK (positive score is good for AI)
                if (p === BLACK) score += 10 + row; // Prefer moving forward
                else if (p === BLACK_KING) score += 30;
                else if (p === RED) score -= 10 + (7 - row);
                else if (p === RED_KING) score -= 30;
            }
            return score;
        }

        function minimax(state, depth, alpha, beta) {
            let legalMoves = getLegalMoves(state);
            
            if (depth === 0 || legalMoves.length === 0) {
                // If game over, heavily penalize the losing side
                if (legalMoves.length === 0) {
                    return { score: state.turn === 'black' ? -1000 : 1000, move: null };
                }
                return { score: evaluateBoard(state.board), move: null };
            }
            
            let isMax = state.turn === 'black';
            let bestMove = null;
            let bestScore = isMax ? -Infinity : Infinity;

            // Randomize move order slightly for variety
            legalMoves.sort(() => Math.random() - 0.5);

            for (let move of legalMoves) {
                let nextState = applyMoveToState(state, move);
                
                // If multi-jump, AI gets another turn, DON'T decrease depth to fully resolve jump chains
                let nextDepth = nextState.turn === state.turn ? depth : depth - 1;
                
                let result = minimax(nextState, nextDepth, alpha, beta);
                let evalScore = result.score;
                
                if (isMax) {
                    if (evalScore > bestScore) {
                        bestScore = evalScore;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, evalScore);
                } else {
                    if (evalScore < bestScore) {
                        bestScore = evalScore;
                        bestMove = move;
                    }
                    beta = Math.min(beta, evalScore);
                }
                
                if (beta <= alpha) break; // Alpha-beta Pruning
            }
            
            return { score: bestScore, move: bestMove || legalMoves[0] };
        }

        function triggerAI() {
            if (gameState.turn !== 'black' || isProcessing) return;
            
            let mode = gameModeSelect.value;
            if (mode === 'pvp') return;

            isProcessing = true;
            turnIndicator.textContent = "AI IS THINKING...";
            turnIndicator.className = "inline-block px-8 py-2 rounded-full font-bold text-sm tracking-widest shadow-lg bg-zinc-800 text-white uppercase";

            // Small delay to allow UI to update and feel natural
            setTimeout(() => {
                let depth = mode === 'ai-easy' ? 1 : mode === 'ai-medium' ? 3 : 5;
                let result = minimax(gameState, depth, -Infinity, Infinity);
                
                if (result.move) {
                    gameState = applyMoveToState(gameState, result.move);
                    updateUI();
                    
                    // If AI has a multi-jump, trigger AI again immediately
                    if (gameState.turn === 'black') {
                        isProcessing = false;
                        setTimeout(triggerAI, 400); 
                    } else {
                        isProcessing = false;
                        checkGameOver();
                    }
                } else {
                    isProcessing = false;
                    checkGameOver();
                }
            }, 100);
        }

        // --- User Interaction & UI ---

        function handleSquareClick(index) {
            if (isProcessing) return; // Block input during AI turn

            // Target square clicked
            let move = currentLegalMoves.find(m => m.to === index && m.from === selectedSquare);
            if (move) {
                gameState = applyMoveToState(gameState, move);
                selectedSquare = null;
                currentLegalMoves = [];
                updateUI();
                
                if (gameState.turn === 'black' && gameModeSelect.value !== 'pvp') {
                    triggerAI();
                } else {
                    checkGameOver();
                }
                return;
            }

            // Piece clicked
            let allMoves = getLegalMoves(gameState);
            let pieceMoves = allMoves.filter(m => m.from === index);
            
            if (pieceMoves.length > 0) {
                selectedSquare = index;
                currentLegalMoves = pieceMoves;
                updateUI();
            } else if (isPlayerPiece(gameState.board[index], gameState.turn)) {
                // Clicked a piece with no valid moves
                selectedSquare = index;
                currentLegalMoves = [];
                updateUI();
            } else {
                selectedSquare = null;
                currentLegalMoves = [];
                updateUI();
            }
        }

        function updateUI() {
            boardElement.innerHTML = '';
            for (let i = 0; i < 64; i++) {
                const square = document.createElement('div');
                const row = Math.floor(i / 8);
                const col = i % 8;
                const isDark = (row + col) % 2 !== 0;
                
                square.className = `relative flex items-center justify-center w-full h-full ${isDark ? 'bg-slate-600' : 'bg-slate-300'}`;
                
                // Highlight last move
                if (gameState.lastMove && (gameState.lastMove.from === i || gameState.lastMove.to === i)) {
                    square.classList.add('last-move');
                }

                if (gameState.board[i] !== EMPTY) {
                    const piece = document.createElement('div');
                    const p = gameState.board[i];
                    const isRed = p === RED || p === RED_KING;
                    const isKing = p === RED_KING || p === BLACK_KING;
                    
                    piece.className = `checker-piece w-[80%] h-[80%] rounded-full shadow-md border-2 flex items-center justify-center 
                        ${isRed ? 'bg-red-500 border-red-600' : 'bg-zinc-800 border-zinc-950'}`;
                    
                    if (isKing) {
                        piece.innerHTML = '<span class="text-white text-xl sm:text-2xl font-bold opacity-80 pb-1">♔</span>';
                    }
                    
                    if (selectedSquare === i) piece.classList.add('selected');
                    if (gameState.multiJumpPiece === i) piece.classList.add('selected'); // Enforce highlight on mandatory jumper
                    
                    square.appendChild(piece);
                }

                if (currentLegalMoves.some(m => m.to === i)) {
                    square.classList.add('valid-move');
                    square.style.cursor = 'pointer';
                }

                square.onclick = () => handleSquareClick(i);
                boardElement.appendChild(square);
            }

            // Turn Indicator
            if (!isProcessing) {
                const turnText = gameState.turn === 'red' ? "Red's Turn" : "Black's Turn";
                const colorClass = gameState.turn === 'red' ? 'bg-red-500' : 'bg-zinc-800';
                turnIndicator.textContent = turnText;
                turnIndicator.className = `inline-block px-8 py-2 rounded-full font-bold text-sm tracking-widest shadow-lg text-white uppercase transition-colors duration-300 ${colorClass}`;
            }
        }

        function checkGameOver() {
            let moves = getLegalMoves(gameState);
            if (moves.length === 0) {
                let winner = gameState.turn === 'red' ? 'Black' : 'Red';
                winnerText.textContent = `${winner} Wins!`;
                winnerText.className = `text-5xl font-extrabold mb-6 ${winner === 'Red' ? 'text-red-500' : 'text-zinc-400'}`;
                gameOverScreen.classList.remove('hidden');
                gameOverScreen.classList.add('flex');
            }
        }

        // Boot
        resetGame();

    </script>
</body>
</html>
